# 第3章 查找

* 符号表
* 二叉树、红黑树、散列表

## 3.1 符号表
* 符号表的主要作用是将一个键和值联系起来。

>定义。符号表是一种存储键值对的数据结构，支持两种操作；插入（put），即将一组新的键值对存入表值，
>查找（get），即根据给定的键得到相应的值。


### 3.1.1 API

*表3.1.2 一种简单的泛型符号表API*    

|  | | |
| ---- | ---- | ---- |
| public class |  ST<Key, Value> | |
|  | ST() | 创建一张符号表 |
| void | put(Key key, Value val) | 将键值对存入表中（若值为空则将键key从表中删除） |
| Value | get(Key key) | 获取键key对应的值（若键key不存在则返回null） |
| void | delete(Key key) | 从表中删除键key（及对应的值） |
| boolean | contains(Key key) | 键key在表中是否有对应的值 |
| boolean |  isEmpty() | 表是否为空 |
| int |  size() | 表中键值对的数量 |
| Iterable\<Key> | keys() | 表中所有的键的集合 |


#### 3.1.1.1 泛型 
#### 3.1.1.2 重复的键
* 实现遵循以下规则
    * 每个键只对应着一个值（表中不允许存在重复的键）。
    * 向表中存入的键值对和表已有的键（及关联的值）冲突时，新的值会代替旧的值。
#### 3.1.1.3 空（null）键 
* 键不能为空
#### 3.1.1.4 空（null）值
* 值不能为空
 
#### 3.1.1.5 删除操作 
* 延时删除：将键对应的值置为空，然后在某个时候删去所有值为空的键。
* 即时删除：立刻从表中删除指定的键。

#### 3.1.1.6 便捷方法 

*表3.1.3 默认实现*    

| 方法 | 默认实现 |
| ---- | ---- | 
| void delete(Key key) | put(key, null) |
| boolean contains(Key key) | return get(key) != null |
| boolean  isEmpty() | return size() == 0 |

#### 3.1.1.7 迭代 
* keys() 返回 Iterable\<Key> 对象方便遍历所有的键。
 
#### 3.1.1.8 键的等价性 
* 对象等价性。
* 最好使用不可变的数据类型作为键，否则表的一致性无法保证。

### 3.1.2 有序符号表
* 键都是Comparable对象。

*表3.1.2 一种有序的泛型符号表API*    

|  | | |
| ---- | ---- | ---- |
| public class |  ST\<Key extends Comparable\<Key>, Value> | |
|  | ST() | 创建一张符号表 |
| void | put(Key key, Value val) | 将键值对存入表中（若值为空则将键key从表中删除） |
| Value | get(Key key) | 获取键key对应的值（若键key不存在则返回null） |
| void | delete(Key key) | 从表中删除键key（及对应的值） |
| boolean | contains(Key key) | 键key在表中是否有对应的值 |
| boolean |  isEmpty() | 表是否为空 |
| int |  size() | 表中键值对的数量 |
| Key | min() | 最小的键 |
| Key | max() | 最小的键 |
| Key | floor(Key key) | 小于等于key的最大键 |
| Key | ceiling(Key key) | 大于等于key的最小值 |
| int | rank(Key key) | 小于key的键的数量 |
| Key | select(int k) | 排名为k的键 |
| void | deleteMin() | 删除最小的键 |
| void | deleteMax() | 删除最大的键 |
| int | size(Key lo, Key hi) | [lo..hi]之间键的数量 |
| Iterable\<Key> | keys(Key lo, Key hi) | [lo..hi]之间所有键，已排序 |
| Iterable\<Key> | keys() | 表中所有的键的集合，已排序 |

#### 3.1.2.1 最大键和最小键
#### 3.1.2.2 向下取整和向上取整
#### 3.1.2.3 排名和选择
#### 3.1.2.4 范围查找
#### 3.1.2.5 列外情况
#### 3.1.2.6 便捷方法
*表3.1.6 有序符号表中冗余有序性方法的默认实现*    

| 方法 | 默认实现 |
| ---- | ---- | 
| void deleteMin(Key key) | delete(min()) |
| void deleteMax(Key key) | delete(max()) |
| boolean isEmpty() | return size() == 0 |
| int size(Key lo, Key hi) |  |
| Iterable\<Key> keys() | keys(min(), max()) |

#### 3.1.2.7 （再谈）等价性
* 为避免任何潜在的二义性，不会在有序符号表中使用equals()方法,
    只使用a.compareTo(b)==0表示a和b是否相等。
    
#### 3.1.2.8 成本模型

### 3.1.3 用例举例
#### 3.1.3.1 行为测试用例

#### 3.1.3.2 性能测试用例
* 从标准输入中得到一列字符串并记录每个（长度至少达到指定的阈值）字符串出现次数，
然后遍历所有键并找出出现频率最高的键。  
[符号表的用例](../src/main/java/ch0301/FrequencyCounter.java)  
```java
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
/**
 * @description: 符号表的用例
 * <p>
 * 从标准输入中得到一列字符串并记录每个（长度至少达到指定的阈值）字符串出现次数，
 * 然后遍历所有键并找出出现频率最高的键。
 */
public class FrequencyCounter {

    public static void main(String[] args) {
        int minlen = Integer.parseInt(args[0]); // 最小键长
        ST<String, Integer> st = new ST<String, Integer>();

        // 1. 统计字符串出现的次数
        while (!StdIn.isEmpty()) {
            // 构造符号表统计频率
            String word = StdIn.readString();
            if (word.length() < minlen) continue; // 忽略较短的单词
            if (!st.contains(word)) st.put(word, 1);
            else st.put(word, st.get(word) + 1);
        }

        // 2. 找出出现频率最高的单词
        String max = " ";
        st.put(max, 0);
        for (String word : st.keys()) {
            if (st.get(word) > st.get(max)) {
                max = word;
            }
        }

        StdOut.println(max + " " + st.get(max));
    }
}
```

* 符号表应用的共性：
    * 混合使用查找和插入
    * 大量不同的键
    * 查找操作比插入操作多得多
    * 虽然不可预测，但查找和插入操作的使用模式并非随机
 
### 3.1.4 无序链表中的顺序查找
* 顺序查找：在查找中一个一个地顺序遍历符号表中所有键，并使用equals()方法来寻找被查找的键匹配的键。

[算法3.1 顺序查找（基于无序链表）](../src/main/java/ch0301/SequentialSearchST.java)

### 3.1.5 无序链表中的顺序查找
[算法3.2 二分查找（基于有序数组）](../src/main/java/ch0301/BinarySearchST.java)

>命题A。在含有N对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要N次比较。
>命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2/2次比较。

>推论。想一个空链表中插入N个不同的键需要~N^2/2次比较。

### 3.1.6 对二分查找的分析
>命题B。在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论是否成功）。  
>向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问~N^2次数组。

## 3.2 二叉查找树

>二叉查找树定义。一棵二叉查找树是一棵二叉树，其中每个结点都有一个Comparable的键（以及相关联的值）
>且每个结点的键都大于其左子树中任意结点的键而小于右子树的任意结点的键。

### 3.2.1 基本实现

#### 3.2.1.1 数据表示
#### 3.2.1.2 查找
#### 3.2.1.3 插入
#### 3.2.1.4 递归

### 3.2.2 分析
>命题C。在由N个随机键构造的二叉查找树中，查找命中平均所需比较次数为~2lnN（约为1.39lnN）。

>命题D。在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2lnN。

### 3.2.3 有序性相关的方法与删除操作
#### 3.2.3.1 最大键与最小键
#### 3.2.3.2 向上取整和向下取整
#### 3.2.3.3 选择操作
#### 3.2.3.4 排名
#### 3.2.3.5 删除最大键和删除最小键
#### 3.2.3.6 删除操作
#### 3.2.3.7 范围查找
#### 3.2.3.8 性能分析
>命题E。在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。

## 3.3 平衡查找树
### 3.3.1 2-3查找数


## 3.4 散列表


## 3.5 应用