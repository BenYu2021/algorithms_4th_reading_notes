# 第3章 查找

* 符号表
* 二叉树、红黑树、散列表

## 3.1 符号表
* 符号表的主要作用是将一个键和值联系起来。

>定义。符号表是一种存储键值对的数据结构，支持两种操作；插入（put），即将一组新的键值对存入表值，
>查找（get），即根据给定的键得到相应的值。


### 3.1.1 API

*表3.1.2 一种简单的泛型符号表API*    

|  | | |
| ---- | ---- | ---- |
| public class |  ST<Key, Value> | |
|  | ST() | 创建一张符号表 |
| void | put(Key key, Value val) | 将键值对存入表中（若值为空则将键key从表中删除） |
| Value | get(Key key) | 获取键key对应的值（若键key不存在则返回null） |
| void | delete(Key key) | 从表中删除键key（及对应的值） |
| boolean | contains(Key key) | 键key在表中是否有对应的值 |
| boolean |  isEmpty() | 表是否为空 |
| int |  size() | 表中键值对的数量 |
| Iterable\<Key> | keys() | 表中所有的键的集合 |


#### 3.1.1.1 泛型 
#### 3.1.1.2 重复的键
* 实现遵循以下规则
    * 每个键只对应着一个值（表中不允许存在重复的键）。
    * 向表中存入的键值对和表已有的键（及关联的值）冲突时，新的值会代替旧的值。
#### 3.1.1.3 空（null）键 
* 键不能为空
#### 3.1.1.4 空（null）值
* 值不能为空
 
#### 3.1.1.5 删除操作 
* 延时删除：将键对应的值置为空，然后在某个时候删去所有值为空的键。
* 即时删除：立刻从表中删除指定的键。

#### 3.1.1.6 便捷方法 

*表3.1.3 默认实现*    

| 方法 | 默认实现 |
| ---- | ---- | 
| void delete(Key key) | put(key, null) |
| boolean contains(Key key) | return get(key) != null |
| boolean  isEmpty() | return size() == 0 |

#### 3.1.1.7 迭代 
* keys() 返回 Iterable\<Key> 对象方便遍历所有的键。
 
#### 3.1.1.8 键的等价性 
* 对象等价性。
* 最好使用不可变的数据类型作为键，否则表的一致性无法保证。

### 3.1.2 有序符号表
* 键都是Comparable对象。

*表3.1.2 一种有序的泛型符号表API*    

|  | | |
| ---- | ---- | ---- |
| public class |  ST\<Key extends Comparable\<Key>, Value> | |
|  | ST() | 创建一张符号表 |
| void | put(Key key, Value val) | 将键值对存入表中（若值为空则将键key从表中删除） |
| Value | get(Key key) | 获取键key对应的值（若键key不存在则返回null） |
| void | delete(Key key) | 从表中删除键key（及对应的值） |
| boolean | contains(Key key) | 键key在表中是否有对应的值 |
| boolean |  isEmpty() | 表是否为空 |
| int |  size() | 表中键值对的数量 |
| Key | min() | 最小的键 |
| Key | max() | 最小的键 |
| Key | floor(Key key) | 小于等于key的最大键 |
| Key | ceiling(Key key) | 大于等于key的最小值 |
| int | rank(Key key) | 小于key的键的数量 |
| Key | select(int k) | 排名为k的键 |
| void | deleteMin() | 删除最小的键 |
| void | deleteMax() | 删除最大的键 |
| int | size(Key lo, Key hi) | [lo..hi]之间键的数量 |
| Iterable\<Key> | keys(Key lo, Key hi) | [lo..hi]之间所有键，已排序 |
| Iterable\<Key> | keys() | 表中所有的键的集合，已排序 |

#### 3.1.2.1 最大键和最小键
#### 3.1.2.2 向下取整和向上取整
#### 3.1.2.3 排名和选择
#### 3.1.2.4 范围查找
#### 3.1.2.5 列外情况
#### 3.1.2.6 便捷方法
*表3.1.6 有序符号表中冗余有序性方法的默认实现*    

| 方法 | 默认实现 |
| ---- | ---- | 
| void deleteMin(Key key) | delete(min()) |
| void deleteMax(Key key) | delete(max()) |
| boolean isEmpty() | return size() == 0 |
| int size(Key lo, Key hi) |  |
| Iterable\<Key> keys() | keys(min(), max()) |

#### 3.1.2.7 （再谈）等价性
* 为避免任何潜在的二义性，不会在有序符号表中使用equals()方法,
    只使用a.compareTo(b)==0表示a和b是否相等。
    
#### 3.1.2.8 成本模型

### 3.1.3 用例举例
#### 3.1.3.1 行为测试用例

#### 3.1.3.2 性能测试用例
* 从标准输入中得到一列字符串并记录每个（长度至少达到指定的阈值）字符串出现次数，
然后遍历所有键并找出出现频率最高的键。  
[符号表的用例](../src/main/java/ch0301/FrequencyCounter.java)  
```java
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
/**
 * @description: 符号表的用例
 * <p>
 * 从标准输入中得到一列字符串并记录每个（长度至少达到指定的阈值）字符串出现次数，
 * 然后遍历所有键并找出出现频率最高的键。
 */
public class FrequencyCounter {

    public static void main(String[] args) {
        int minlen = Integer.parseInt(args[0]); // 最小键长
        ST<String, Integer> st = new ST<String, Integer>();

        // 1. 统计字符串出现的次数
        while (!StdIn.isEmpty()) {
            // 构造符号表统计频率
            String word = StdIn.readString();
            if (word.length() < minlen) continue; // 忽略较短的单词
            if (!st.contains(word)) st.put(word, 1);
            else st.put(word, st.get(word) + 1);
        }

        // 2. 找出出现频率最高的单词
        String max = " ";
        st.put(max, 0);
        for (String word : st.keys()) {
            if (st.get(word) > st.get(max)) {
                max = word;
            }
        }

        StdOut.println(max + " " + st.get(max));
    }
}
```

* 符号表应用的共性：
    * 混合使用查找和插入
    * 大量不同的键
    * 查找操作比插入操作多得多
    * 虽然不可预测，但查找和插入操作的使用模式并非随机
 
### 3.1.4 无序链表中的顺序查找
* 顺序查找：在查找中一个一个地顺序遍历符号表中所有键，并使用equals()方法来寻找被查找的键匹配的键。

[算法3.1 顺序查找（基于无序链表）](../src/main/java/ch0301/SequentialSearchST.java)

### 3.1.5 无序链表中的顺序查找
[算法3.2 二分查找（基于有序数组）](../src/main/java/ch0301/BinarySearchST.java)

>命题A。在含有N对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要N次比较。
>命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2/2次比较。

>推论。想一个空链表中插入N个不同的键需要~N^2/2次比较。

### 3.1.6 对二分查找的分析
>命题B。在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论是否成功）。  
>向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此向一个空符号表中插入N个元素在最坏情况下需要访问~N^2次数组。

## 3.2 二叉查找树

>二叉查找树定义。一棵二叉查找树是一棵二叉树，其中每个结点都有一个Comparable的键（以及相关联的值）
>且每个结点的键都大于其左子树中任意结点的键而小于右子树的任意结点的键。

### 3.2.1 基本实现

#### 3.2.1.1 数据表示
#### 3.2.1.2 查找
#### 3.2.1.3 插入
#### 3.2.1.4 递归

### 3.2.2 分析
>命题C。在由N个随机键构造的二叉查找树中，查找命中平均所需比较次数为~2lnN（约为1.39lnN）。

>命题D。在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2lnN。

### 3.2.3 有序性相关的方法与删除操作
#### 3.2.3.1 最大键与最小键
#### 3.2.3.2 向上取整和向下取整
#### 3.2.3.3 选择操作
#### 3.2.3.4 排名
#### 3.2.3.5 删除最大键和删除最小键
#### 3.2.3.6 删除操作
#### 3.2.3.7 范围查找
#### 3.2.3.8 性能分析
>命题E。在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。

## 3.3 平衡查找树
* 前面的查找算法在最坏的情况下的性能很糟。

### 3.3.1 2-3查找树
>2-3查找树定义。一棵2-3查找树或为一棵空树。
>    * 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
>    * 3-结点，含有一个键（及其对应的值）和三条链接，左链接指向2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，
>    右链接指向的2-3树中的键都大于该结点。

* 指向一棵空树的链接为空链接。
    
#### 3.3.1.1 查找
#### 3.3.1.2 向2-结点插入新键
#### 3.3.1.3 向一棵只含有一个3-结点的树中插入新键
#### 3.3.1.4 向一个父结点为2-结点的3-结点中插入新键
#### 3.3.1.5 向一个父结点为3-结点的3-结点插入新键
#### 3.3.1.6 分解根节点
#### 3.3.1.7 局部变换
#### 3.3.1.8 全局性质

### 3.3.2 红黑二叉查找树

#### 3.3.2.1 替换3-结点
* 红黑二叉查找树基本思想是：用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。
    * 红链接：将两个2-结点连接起来构成一个3-结点。
    * 黑链接：2-3树中的普通链接。

#### 3.3.2.2 一种等价定义
* 红黑树的另一种等价定义是含有红黑链接并满足下列条件的二叉查找树：
    * 红链接均为左链接；
    * 没有任何一个结点同时和两条红链接相连；
    * 该树是完美黑色平衡的，即任意空链接到根节点上的黑链接数量相同。
#### 3.3.2.3 一一对应
* 红黑树既是二叉查找树，也是2-3树。
#### 3.3.2.4 颜色表示 
```java
    public static final boolean BLACK = true;
    public static final boolean RED = false;

    private class Node {
        Key key; // 键
        Value value; // 值
        Node left, right; // 左右子树
        int N; // 这棵子树中的结点总数
        boolean color;

        public Node(Key key, Value value, int n, boolean color) {
            this.key = key;
            this.value = value;
            this.N = n;
            this.color = color;
        }
    }

    private boolean isRed(Node x) {
        if (x == null) return false;
        return x.color == RED;
    }
```

#### 3.3.2.5 旋转

#### 3.3.2.6 左旋转后重置父结点的链接
#### 3.3.2.7 向单个2-结点插入新键
* 插入新键
    * 新键小于老键，新增一个红色结点
    * 新键大于老键，新增的红色结点产生一条红色右链接，需要使用root = rotateLeft(root),
    将其旋转为红色左链接并修正结点的链接。 
#### 3.3.2.8 向底部的2-结点插入新键
#### 3.3.2.9 向一棵双键树（即一个3-结点）中插入新键 
#### 3.3.2.10 颜色转换
#### 3.3.2.11 根结点总是黑色
#### 3.3.2.12 向树底部的3-结点插入新键
#### 3.3.2.13 将红链接在树中向上传递

### 3.3.3 实现
[算法3.4 红黑树](../src/main/java/ch0303/RedBlackTree.java)

### 3.3.4 删除操作（暂时没有细看）

#### 3.3.4.1 自顶向下的2-3-4树
#### 3.3.4.2 删除最小键
#### 3.3.4.3 删除操作

### 3.3.5 红黑树的性质
* 所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别（范围查找除外，它所需的额外时间和返回的键的数量成正比）。

>命题G。一棵大小为N的红黑树的高度不会超过2lgN。

>命题H。一棵大小为N的红黑树中，根结点到任意及诶单的平均路径长度为~1.00lgN。


## 3.4 散列表
* 散列表查找算法分两步：
    * 用散列函数将被查找的键转化为数组的一个索引。
    * 一个处理碰撞冲突的过程（拉链法和线性探测法）。
    
### 3.4.1 散列函数
* 散列函数应易于计算并且能均匀分布所有的键。
#### 3.4.1.1 典型例子
#### 3.4.1.2 正整数
* 
#### 3.4.1.3 浮点数
#### 3.4.1.4 字符串
#### 3.4.1.5 组合键
#### 3.4.1.6 Java约定
* 每一种数据类型的hashCode()方法都必须和equals()方法一致。
    * 如果a.equals(b)返回true，那么a.hashCode()的返回值必须和b.hashCode()的值相等。
    * 如果两个对象的hashCode()方法的返回值相同，这两个对象也可能不同，还需要equals()方法进行判断。
#### 3.4.1.7 将hashCode()返回值转化为一个数组索引
#### 3.4.1.8 自定义hashCode()函数
#### 3.4.1.9 软缓存
* 在每个键中用一个hash变量来保存它的hashCode()返回值。

* 优秀的散列方法需要满足三个条件：
    * 一致性 -- 等价的键必然产生相等的散列值；
    * 高效性 -- 计算简便；
    * 均匀性 -- 均匀地散列所有的键。
    
> 假设J（均匀散列假设）。我们使用的散列函数能够均匀并独立地将所有的键散布于0到M-1之间。

### 3.4.2 基于拉链法的散列表
>命题K。在一张含有M条链表和N个键的散列表中，（在假设J成立的前提下）任意一条链表中的键的数量
>均在N/M的常数因子范围内的概率无限趋向于1。

>性质L。在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M。

#### 3.4.2.1 散列表的大小
#### 3.4.2.2 删除操作
#### 3.4.2.3 有序性相关操作
* 散列表最主要的目的在于均匀地将键散布开来，因此在计算散列后键的顺序信息就丢失了。

### 3.4.3 基于线性探测法的散列表


## 3.5 应用

### 3.5.1 我们应该使用符号表的哪种实现

#### 3.5.1.1 原始数据类型
#### 3.5.1.2 重复键
#### 3.5.1.3 Java标准库


### 3.5.2 集合API

*表3.1.2 一种有序的泛型符号表API*    

|  | | |
| ---- | ---- | ---- |
| public class |  SET\<Key> | |
|  | SET() | 创建一个空的集合 |
| void | add(Key key) | 将键key加入集合 |
| void | delete(Key key) | 将键key从集合中删除 |
| boolean | contains(Key key) | 键key是否在集合之中 |
| boolean | isEmpty() | 集合是否为空 |
| void | size() | 集合中键的数量 |
| String | toString() | 对象的字符串表示 |


#### 3.5.2.1 dedup
#### 3.5.2.2 白名单和黑名单

### 3.5.3 字典类用例
### 3.5.4 索引类用例

#### 反向索引
* 反向索引一般指用值来查找键的操作。


### 3.5.5 稀疏矩阵

