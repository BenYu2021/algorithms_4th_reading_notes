# 第1章 基础

## 算法
* 抽象数据类型（ADT）
* 三种基础抽象数据类型：背包、队列、栈
* 分析算法性能的基本方法：
    + 对性能提出假设
    + 建立数学模型
    + 多种实验验证
    
* 算法：有限的、确定的、有效的并适合用于计算机程序来实现的解决问题的方法。
* 为了组织数据就产生了数据结构。
* 抽象

[GCD.java](../src/main/java/ch01/GCD.java)  

## 1.1 基础编程模型
### 1.1.1 Java程序的基本结构
### 1.1.2 原始数据类型与表达式
#### 1.1.2.1 表达式
* Java使用的是中缀表达式：一个字面量（或一个表达式） 运算符 一个字面量（或一个表达式）
#### 1.1.2.1 类型转换
#### 1.1.2.1 比较
#### 1.1.2.1 其他原始类型

### 1.1.3 语句
* Java程序是由语句组成。
* 语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。
    * 声明语句
    * 赋值语句
    * 条件语句
    * 循环语句
    * break和continue  

### 1.1.5 数组
### 1.1.6 静态方法 
### 1.1.7 API
### 1.1.8 字符串
### 1.1.9 输入和输出
### 1.1.10 二分查找

## 1.2 数据抽象
* 数据类型：一组值和一组对这些值操作的集合。
* 数据抽象：定义和使用数据类型。
* 抽象数据类型：一种能够对使用者隐藏数据表示的数据类型。

### 1.2.1 使用抽象数据类型
#### 1.2.1.1 抽象数据类型的API
#### 1.2.1.2 继承的方法
#### 1.2.1.2 继承的方法
#### 1.2.1.4 对象
* 对象的三大重要特性：
    * 状态：数据类型中的值
    * 标识：对象的标识能够将一个对象区别于另一个对象
    * 行为：数据类型的操作
    
* 数据类型的实现的唯一职责就是维护一个对象的身份。
#### 数组也是对象


### 1.2.3 抽象数据类型的实现
### 1.2.3.1 实例变量
### 1.2.3.2 构造函数
### 1.2.3.3 实例方法
### 1.2.3.4 作用域

## 1.3 背包、队列和栈
### 1.3.1 API

*表1.3.1 泛型可迭代的基础集合数据类型的API*  

| 背包 | | |
| ---- | ---- | ---- |
| public class | Bag\<Item> implements Iterable\<Item> | |
| | Bag() | 创建一个空背包 |
| void | add(Item item) | 添加一个元素 |
| boolean | isEmpty() | 背包是否为空 |
| int | size() | 背包中的元素数量 |

| 先进先出（FIFO）队列 | | |
| ---- | ---- | ---- |
| public class |  Queue\<Item> implements Iterable\<Item> | |
|  |  Queue() | 创建一个空队列 |
| void |  enqueue(Item item) | 添加一个元素 |
| Item |  dequeue() | 删除最早添加的元素 |
| boolean |  isEmpty() | 队列是否为空 |
| int |  size() | 队列中的元素数量 |
 
| 下压（后进先出，LIFO）栈 | | |
| ---- | ---- | ---- |
| public class |  Stack\<Item> implements Iterable\<Item> | |
|  |  Stack() | 创建一个空栈 |
| void |  push(Item item) | 添加一个元素 |
| Item |  pop() | 删除最近添加的元素 |
| boolean |  isEmpty() | 栈是否为空 |
| int |  size() | 栈中的元素数量 |

#### 1.3.1.1 泛型
#### 1.3.1.2 自动装箱
#### 1.3.1.3 可迭代的集合类型
#### 1.3.1.4 背包
#### 1.3.1.5 先进先出队列
#### 1.3.1.6 下压栈


### 1.3.2 集合数据类型的实现
#### 1.3.2.1 定容栈
#### 1.3.2.2 泛型
* Java中不允许创建泛型数组。需要使用类型转换
#### 1.3.2.3 调整数组大小

#### 1.3.2.4 对象游离
* 对象游离的解决方法：将被弹出的数值元素设置为null
#### 1.3.2.5 迭代


表1.3.2    

*表1.3.2 一种表示定容字符串栈的抽象数据类型*    
   

| 定容栈 | | |
| ---- | ---- | ---- |
| public class |  FixedCapacityStackOfStrings | |
|  |  FixedCapacityStackOfStrings(int cap) | 创建一个容量为cap的空栈 |
| void |  push(String item) | 添加一个字符串 |
| String |  pop() | 删除最近添加的字符串 |
| boolean |  isEmpty() | 栈是否为空 |
| int |  size() | 栈中的字符串数量 |

*表1.3.4 一种表示定容栈的抽象数据类型*    
   
| 定容栈 | | |
| ---- | ---- | ---- |
| public class |  FixedCapacityStack\<Item> | |
|  |  FixedCapacityStack(int cap) | 创建一个容量为cap的空栈 |
| void |  push(Item item) | 添加一个元素 |
| Item |  pop() | 删除最近添加的元素 |
| boolean |  isEmpty() | 栈是否为空 |
| int |  size() | 栈中的元素数量 |



### 1.3.3 链表
### 1.3.3.1 节点记录
### 1.3.3.2 构造链表
### 1.3.3.3 在表头插入节点
### 1.3.3.4 从表头删除节点
### 1.3.3.5 在表尾插入节点
### 1.3.3.6 从其他位置的插入和删除操作
### 1.3.3.7 遍历
### 1.3.3.8 栈的实现


### 1.3.3.5 在表尾插入节点
### 1.3.3.5 在表尾插入节点

### 1.3.3.1 节点记录


## 1.4 算法分析
### 1.4.1 科学方法
### 1.4.2 观察
* 将问题规模和运行时间量化

### 1.4.3 科学模型
### 1.4.3 增长的数量级分类


### 1.4.5 设计更快的算法
### 1.4.6 倍率实验
### 1.4.7 注意事项
### 1.4.8 处理对输入的依赖
### 1.4.9 内存 

## 1.5 案例研究：union-find算法
