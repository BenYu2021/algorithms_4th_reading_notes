# 第2章 排序

## 2.1 初级排序

### 2.1.1 游戏规则
* 
[排序算法的模版](../src/main/java/ch0201/Example.java)
```java
package ch0201;

import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.StdOut;

/**
 * @description: 排序算法类的模版
 */
public class Example {

    /**
     * 将数组a[]按升序排序
     *
     * @param a
     */
    public static void sort(Comparable[] a) {

    }

    /**
     * 判断v是否小于w
     *
     * @param v
     * @param w
     * @return
     */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    /**
     * 交换数组中索引为i,j的元素
     *
     * @param a
     * @param i
     * @param j
     */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    /**
     * 在单行中打印数组
     *
     * @param a
     */
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++)
            StdOut.print(a[i] + " ");
        StdOut.println();
    }

    /**
     * 判断数组元素是否有序（升序）
     *
     * @param a
     * @return
     */
    public static boolean isSorted(Comparable[] a) {
        for (int i = 1; i < a.length; i++) {
            if (less(a[i], a[i - 1])) return false;
        }
        return true;
    }

    public static void main(String[] args) {
        // 从标准输入读取字符串，并将它们排序并输出
        String[] a = In.readStrings();

        sort(a);
        assert isSorted(a);
        show(a);
    }

}
```
#### 2.1.1.1 验证
#### 2.1.1.2 运行时间
>排序的成本模型。在研究排序算法时。我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数。

#### 2.1.1.3 额外的内存使用
* 排序算法分类：
    * 原地排序算法：除函数调用所需的栈和固定数目的实例变量之外，无序额外内存。
    * 其它算法
#### 2.1.1.4 数据类型
* compareTo()必须实现一个全序关系：
    * 自反性：对于所有的v，v=v；
    * 反对称性：对于所有的 v<w，都有v>w不成立，且v=w时，w=v
    * 传递性：对于所有的v、w和x，如果v<=w且w<=x，则v<=x。

### 2.1.2 选择排序
* 算法描述
    1. 首先，找到数组中最小的那个元素，
    2. 其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素，那么它就和自己交换），
    3. 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，
    4. 如此往复，直到将整个数组排序。

> 命题A。对于长度为N的数组，选择排序需要大约N^2/2此比较

* 两个鲜明特点：
    * 运行时间和输入无关
    * 数据移动最少

[算法2.1 选择排序](../src/main/java/ch0201/Selection.java)
```java

```

### 2.1.3 插入排序

>命题B。对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要~N^2/4次比较，以及~N^2/4次交换。
>最坏情况下需要~N^2/2次比较和~N^2/2次交换，最好情况下需要N-1次比较和0次交换。

* 倒置：数组中的两个顺序颠倒的元素。
* 部分有序：数组中倒置的数量小于数组大小的某个倍数。

[算法2.2 插入排序](../src/main/java/ch0201/Insertion.java)
```java

```

>命题C。插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

* 插入排序对部分有序的数组十分高效，也很适合小规模数组。

### 2.1.4 排序算法的可视化
### 2.1.5 比较两种排序算法
>命题D。对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。

[比较两种排序算法](../src/main/java/ch0201/SortCompare.java)
```java

```

### 2.1.6 希尔排序
* 基于插入排序的快速排序算法。
* 插入排序缺点：大规模乱序数组排序慢，因为它只会交换相邻元素，因此元素只能一点点地从数组的一端移动到另一端。
* 希尔排序改进插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序数组排序。
* 希尔排序的思想：使数组中任意间隔h的元素是有序的。这样的数组称为h有序数组。
* 递增序列
* 希尔排序更高效的原因：它权衡了子数组的规模和有序性。
    排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。
* 希尔排序是唯一无法准确描述其对于乱序的数组性能特征的排序方法。

[算法2.3希尔排序](../src/main/java/ch0201/Shell.java)
```java

```

* 如何选择递增序列？
    算法性能不仅取决于h，还取决于h之间的数学性质。
    
* 贯穿本书的重要理念：
    通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因。

>命题E。使用递增序列1，4，13,40，121，364...的希尔排序所需的比较次数不会超过N的若干倍乘以递增序列的长度。

## 2.2 归并排序
* 归并：将两个有序数组归并成一个更大的有序数组。
* 归并排序：先（递归地）将数组分成两半分别排序，然后将结果归并起来。
* 性质：
    * 优点：将任意长度为N的数值排序所需时间和NlgN成正比。
    * 缺点：所需额外空间和N成正比。

### 2.2.1 原地归并排序的抽象方法

* 归并排序所需的时间和NlgN成正比。
* 只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。
    * 优点：可以归并排序处理数百万甚至更大的数组，这是插入排序和选择排序所做不到的。
    * 缺点：辅助数组大于和数组长度N成正比。
    
#### 原地归并排序的抽象方法
```java

    /**
     * 原地归并抽象方法，
     * a[lo..mid]和a[mid+1..hi]为有序数组
     * @param a
     * @param lo
     * @param mid
     * @param hi
     */
    public static void merge(Comparable[] a, int lo, int mid, int hi) {
        // 将a[lo]...a[hi]归并
        int i = lo, j = mid + 1;

        for (int k = lo; k <= hi; k++)  // 将a[lo...hi]复制到aux[lo...hi]
            aux[k] = a[k];

        for (int k = lo; k <= hi; k++) { // 归并a[lo..hi]复制到aux[lo..hi]
            if (i > mid)                    a[k] = aux[j++]; // 左半边用尽（取右半边的元素）
            else if (j > hi)                a[k] = aux[i++]; // 右半边用尽（取左半边的元素）
            else if (less(aux[j], aux[i]))  a[k] = aux[j++]; // 右半边的当前元素小于左半边的当前元素（取右边的元素）
            else                            a[k] = aux[i++]; // 右半边的当前元素大于等于左半边的当前元素（取左边的元素）
        }

    }
```

### 2.2.2 自顶向下的归并排序
[算法2.4 自顶向下的归并排序](../src/main/java/ch0202/Merge.java)

>命题F。对于长度为N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较。

>命题G。对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次。

#### 2.2.2.1 对小规模子数组使用插入排序
* 用不同方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中的方法的调用过于频繁，
所以改进对它们的处理方法就能改进整个算法。

* note:
    并不是递归到1

#### 2.2.2.2 测试数组是否已经有序
* 添加一个判断条件：a[mid] < a[mid + 1]，就认为数组已经有序，并跳过merge()方法。
#### 2.2.2.3 不将元素复制到辅助数组
* 研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。

### 2.2.3 自底向上的归并排序
>命题H。对于长度为N的任意数组，自底向上的归并排序需要1/2NlgN至NlgN次比较，最多需要访问数组6NlgN次。

* 自底向上的归并排序比较适合用链表组织的数据。这种方法只需要重新组织链表连接就能将链表原地排序。

### 2.2.4 排序算法的复杂度
>命题I。没有任何基于比较的算法能够保证使用少于lg(N!) ~ Nlg(N)次比较将长度为N的数组排序。

>命题J。归并排序是一种渐进最优的基于比较排序的算法。


## 2.3 快速排序
* 应用最广泛的算法。
* 流行的原因：实现简单，适用于各种不同的输入数据且在应用中比其他排序算法都快得多。
* 优缺点
    * 优点：快速排序是原地排序（只需要一个很小的辅助栈），长度为N的数组排序时间和NlgN成正比。
        
    * 缺点：
        * 非常脆弱，在实现时要非常小心才能避免低劣的性能。

### 2.3.1 基本算法
* 快速排序是一种分治的排序算法。

### 2.3.1.1 原地切分
### 2.3.1.2 别越界
### 2.3.1.3 保持随机性
### 2.3.1.4 终止循环
### 2.3.1.5 处理切分元素值有重复情况
### 2.3.1.6 终止递归

### 2.3.2 性能特点
* 比较次数少。

>命题K。将长度为N的无重复数组排序，快速排序平均需要~2NlnN次比较（以及1/6的交换）。

>命题L。快速排序最多需要N^2/2次比较，但随机打乱的数组能够预防这种情况。

### 2.3.3 算法改进

#### 2.3.3.1 切换到插入排序（习题2.3.25）
#### 2.3.3.2  三取样切分（练习2.3.18、19）
* 人们发现将取样大小设置为3并且用大小居中的元素切分效果最好。

#### 2.3.3.3 熵最优的排序

>命题M。不存在任何基于比较的排序算法能够保证在NH-H次比较之内将N个元素排序，其中H为主键出现频率定义的香浓信息量。

* 术语解释：  
    * [香农熵](https://baike.baidu.com/item/%E9%A6%99%E5%86%9C%E7%86%B5)  
    * [信息量](https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E9%87%8F)  
    * [信息论](https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E8%AE%BA)  
    * [香浓信息量](https://blog.csdn.net/weixinhum/article/details/85059320)
>命题N。对于大小为N的数组，三向切分的快速排序需要~(2ln2)NH次比较。其中H为由主键值出现频率定义的香浓信息量。

## 2.4 优先队列
* 优先队列：支持删除最大元素和删除元素的数据类型。
* 二叉堆
* 

### 2.4.1 API

*表2.4.1 泛型优先队列*

| 定容栈 | | |
| ---- | ---- | ---- |
| public class |  MaxPQ\<Key extends Comparable\<Key>> | |
|  |  MaxPQ() | 创建一个优先队列 |
|  |  MaxPQ(int max) | 创建一个初始容量为max的优先队列 |
|  |  MaxPQ(Key[] a) | 用a[]中的元素初始化一个优先队列 |
| void |  insert(Key v) | 向优先队列中插入一个元素 |
| Key |  max() | 返回最大元素 |
| Key |  Key delMax() | 删除并返回最大元素 |
| boolean |  isEmpty() | 返回队列是否为空 |
| int |  size() | 返回优先队列中的元素个数 |

#### 优先队列的调用示例
TopM

### 2.4.2 初级实现
#### 2.4.2.1 数组实现（无序）
#### 2.4.2.2 数组实现（有序）
#### 2.4.2.3 链表表示法
* 惰性方法：使用无序序列
* 积极方法：使用有序序列



### 2.4.3堆的定义
>当一颗二叉树的每个结点都大于等于它的两个子节点时，它被称为堆有序。

>命题O。根结点是堆有序的二叉树中的最大结点。

#### 二叉堆表示法

> 定义。二叉堆是一组能够用堆排序的完全二叉树排序的元素，并在数组中按层级存储（不使用数组的第一个位置）。

* 在一个二叉堆中，位置k的结点的父结点的位置为inf k/2，两个子节点为2k，2k+1。

> 命题P。一棵大小为N的完全二叉树的高度为inf lgN。

注：
上确界 supremum：sup
下确界 infimum：inf

### 2.4.4 堆的算法
* 堆的有序化：打破堆的状态，然后再遍历堆并按照要求将堆恢复。

* 优先队列由一个基于堆的完全二叉树表示。

>命题Q。对于一个含有N个元素基于堆的优先队列，插入元素操作只需不超过（lgN + 1）次比较，删除最大元素的操作不超过分2lgN次比较。

### 2.4.4.1 由下至上的堆有序化（上浮）
```java
    private void swim(int k) {
        while(k > 1) {
            exch(k/2, k);
            k = k/2;
        }
    }
```

### 2.4.4.2 由上至下的堆有序化（下沉）

```java
    private void sink(int k) {
        while(2*k <= N) {
            int j = 2*k;        // 左子结点
            if(j  < N && less(j, j+1)) j++; // 左子结点小于右子结点
            if(!less(k, j)) break;          // k节点比左右结点都大
            exch(k, j);
            k = j; 
        }
    }
```

>命题Q。对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，
>删除最大元素的操作需要不超过2lgN次比较。  
>在一个大小为N的索引优先队列中，插入元素、改变优先级、删除和删除最小元素操作所需的比较次数和lgN成正比。

#### 2.4.4.3 多叉堆
#### 2.4.4.4 调整数组大小
#### 2.4.4.5 元素不变性
#### 2.4.4.6 索引优先队列

*表2.4.5 关联索引的泛型优先队列*    

|  | | |
| ---- | ---- | ---- |
| public class |  IndexMinPQ<Item extends Comparable<Item>> | |
|  |  IndexMinPQ(int maxN) | 创建一个最大容量为maxN的优先队列，索引范围为0~maxN-1 |
| void | insert(int k, Item item) | 插入一个元素，将它和索引k向关联 |
| void | change(int k, Item item) |  将索引k的元素设置我item |
| boolean | contains(int k) |  是否存在索引为k的元素 |
| void | delete(int k) |  删除索引为k的元素 |
| Item | min() |  返回最小元素 |
| int | minIndex() |  返回最小元素的索引 |
| int |delMin() |  删除最小元素并返回它的索引 |
| boolean |  isEmpty() | 是否为空 |
| int |  size() | 元素的数量 |

#### 2.4.4.7 索引优先队列用例


### 2.4.5 堆排序

#### 2.4.5.1 堆的构造
>命题R。用下沉操作由N个元素构造堆只需少于2N次比较，以及少于N次交换。

[算法2.7 堆排序](../src/main/java/ch0204/)
#### 2.4.5.2 下沉排序

#### 2.4.5.3 先下沉后上浮

## 2.5 应用

